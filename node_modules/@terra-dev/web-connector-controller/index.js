import { WebConnectorStatusType, } from '@terra-dev/web-connector-interface';
import bowser from 'bowser';
import { BehaviorSubject } from 'rxjs';
async function getConnector(hostWindow) {
    return new Promise((resolve) => {
        let count = 20;
        function task() {
            if (--count > 0) {
                if (typeof hostWindow.terraWebConnectors !== 'undefined' &&
                    Array.isArray(hostWindow.terraWebConnectors) &&
                    hostWindow.terraWebConnectors.length > 0) {
                    console.log(`TerraWebConnector: `, JSON.stringify(hostWindow.terraWebConnectors[0].getInfo()));
                    resolve(hostWindow.terraWebConnectors[0]);
                }
                else {
                    console.warn(`Can't find window.terraWebConnectors. wait 500ms...`);
                    setTimeout(task, 500);
                }
            }
            else {
                resolve(undefined);
            }
        }
        task();
    });
}
export class WebConnectorController {
    constructor(hostWindow) {
        this.hostWindow = hostWindow;
        this._connector = null;
        /**
         * Refetch the clientsStates
         *
         * You don't need call this method in most cases.
         * Normally, when the clientStates is changed, states() get the new clientStates.
         *
         * @example
         * client.states()
         *       .subscribe(states => {
         *         // 2. will get new clientStates
         *         console.log('Got new states', Date.now())
         *       })
         *
         * function callback() {
         *   // 1. refetch client states
         *   client.refetchStates()
         * }
         */
        this.refetchStates = () => {
            var _a;
            (_a = this._connector) === null || _a === void 0 ? void 0 : _a.refetchStates();
        };
        /**
         * Request approval connection to the Extension. (Connect)
         */
        this.requestApproval = () => {
            var _a;
            (_a = this._connector) === null || _a === void 0 ? void 0 : _a.requestApproval();
        };
        this.status = () => {
            return this._status.asObservable();
        };
        this.getLastStatus = () => {
            return this._status.getValue();
        };
        /**
         * Execute transaction
         *
         * @example
         * client.post(terraAddress, tx: CreateTxOptions)
         *       .subscribe({
         *          next: (result: WebConnectorTxProgress | WebConnectorTxSucceed) => {
         *            switch (result.status) {
         *              case WebConnectorTxStatus.PROGRESS:
         *                console.log('in progress', result.payload)
         *                break;
         *              case WebConnectorTxStatus.SUCCEED:
         *                console.log('succeed', result.payload)
         *                break;
         *            }
         *          },
         *          error: (error) => {
         *            if (error instanceof WebConnectorUserDenied) {
         *              console.log('user denied')
         *            } else if (error instanceof WebConnectorCreateTxFailed) {
         *              console.log('create tx failed', error.message)
         *            } else if (error instanceof WebConnectorTxFailed) {
         *              console.log('tx failed', error.txhash, error.message, error.raw_message)
         *            } else {
         *              console.log('unspecified error', 'message' in error ? error.message : String(error))
         *            }
         *          }
         *       })
         *
         * @description The stream will be
         * TxProgress -> [...TxProgress] -> TxSucceed
         *
         * - Tx is Succeed : TxProgress -> [...TxProgress] -> TxSucceed
         */
        this.post = (terraAddress, tx) => {
            return this._connector.post(terraAddress, tx);
        };
        /**
         * Add CW20 Token to extension dashboard
         */
        this.addCW20Tokens = (chainID, ...tokenAddrs) => {
            return this._connector.addCW20Tokens(chainID, ...tokenAddrs);
        };
        this.hasCW20Tokens = (chainID, ...tokenAddrs) => {
            return this._connector.hasCW20Tokens(chainID, ...tokenAddrs);
        };
        /**
         * @example
         * client.states()
         *       .subscribe(states => {
         *         if (!states) {
         *           console.log('client is still not ready')
         *         } else {
         *           console.log('current network is', states.network)
         *           console.log('current wallets are', states.wallets)
         *         }
         *       })
         */
        this.states = () => {
            return this._states.asObservable();
        };
        this.getLastStates = () => {
            return this._states.getValue();
        };
        /**
         * Destroy this client
         *
         * - Unsubscribe all RxJs Subjects (every Observables are stoped)
         */
        this.destroy = () => {
            var _a;
            (_a = this._connector) === null || _a === void 0 ? void 0 : _a.close();
            this._connector = null;
        };
        this._status = new BehaviorSubject({
            type: WebConnectorStatusType.INITIALIZING,
        });
        this._states = new BehaviorSubject(null);
        const browser = bowser.getParser(navigator.userAgent);
        //@ts-ignore
        getConnector(hostWindow).then((connector) => {
            if (!connector) {
                const name = browser.getBrowserName(true);
                let installLink;
                switch (name) {
                    case 'chrome':
                    case 'microsoft edge':
                        installLink = 'https://google.com/chrome';
                        break;
                    case 'firefox':
                        installLink = 'https://google.com/firefox';
                        break;
                    case 'safari':
                        installLink = 'https://google.com/safari';
                        break;
                    default:
                        installLink = 'https://google.com/chrome';
                        break;
                }
                this._status.next({
                    type: WebConnectorStatusType.NO_AVAILABLE,
                    isConnectorExists: false,
                    installLink,
                });
                return;
            }
            if (!connector.checkBrowserAvailability(navigator.userAgent)) {
                this._status.next({
                    type: WebConnectorStatusType.NO_AVAILABLE,
                    isConnectorExists: true,
                    isSupportBrowser: false,
                });
                return;
            }
            connector.open(hostWindow, this._status, this._states);
            this._connector = connector;
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvQHRlcnJhLWRldi93ZWItY29ubmVjdG9yLWNvbnRyb2xsZXIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUlMLHNCQUFzQixHQUV2QixNQUFNLG9DQUFvQyxDQUFDO0FBRTVDLE9BQU8sTUFBTSxNQUFNLFFBQVEsQ0FBQztBQUM1QixPQUFPLEVBQUUsZUFBZSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBRW5ELEtBQUssVUFBVSxZQUFZLENBQUMsVUFFM0I7SUFDQyxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDN0IsSUFBSSxLQUFLLEdBQUcsRUFBRSxDQUFDO1FBRWYsU0FBUyxJQUFJO1lBQ1gsSUFBSSxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUU7Z0JBQ2YsSUFDRSxPQUFPLFVBQVUsQ0FBQyxrQkFBa0IsS0FBSyxXQUFXO29CQUNwRCxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQztvQkFDNUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQ3hDO29CQUNBLE9BQU8sQ0FBQyxHQUFHLENBQ1QscUJBQXFCLEVBQ3JCLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQzNELENBQUM7b0JBQ0YsT0FBTyxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUMzQztxQkFBTTtvQkFDTCxPQUFPLENBQUMsSUFBSSxDQUFDLHFEQUFxRCxDQUFDLENBQUM7b0JBQ3BFLFVBQVUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7aUJBQ3ZCO2FBQ0Y7aUJBQU07Z0JBQ0wsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQ3BCO1FBQ0gsQ0FBQztRQUVELElBQUksRUFBRSxDQUFDO0lBQ1QsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQsTUFBTSxPQUFPLHNCQUFzQjtJQUtqQyxZQUFvQixVQUFrQjtRQUFsQixlQUFVLEdBQVYsVUFBVSxDQUFRO1FBRjlCLGVBQVUsR0FBNkIsSUFBSSxDQUFDO1FBMkRwRDs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FpQkc7UUFDSCxrQkFBYSxHQUFHLEdBQUcsRUFBRTs7WUFDbkIsTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRSxhQUFhLEVBQUUsQ0FBQztRQUNuQyxDQUFDLENBQUM7UUFFRjs7V0FFRztRQUNILG9CQUFlLEdBQUcsR0FBRyxFQUFFOztZQUNyQixNQUFBLElBQUksQ0FBQyxVQUFVLDBDQUFFLGVBQWUsRUFBRSxDQUFDO1FBQ3JDLENBQUMsQ0FBQztRQUVGLFdBQU0sR0FBRyxHQUFHLEVBQUU7WUFDWixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDckMsQ0FBQyxDQUFDO1FBRUYsa0JBQWEsR0FBRyxHQUFHLEVBQUU7WUFDbkIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pDLENBQUMsQ0FBQztRQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FpQ0c7UUFDSCxTQUFJLEdBQUcsQ0FDTCxZQUFvQixFQUNwQixFQUFtQixFQUNlLEVBQUU7WUFDcEMsT0FBTyxJQUFJLENBQUMsVUFBVyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDakQsQ0FBQyxDQUFDO1FBRUY7O1dBRUc7UUFDSCxrQkFBYSxHQUFHLENBQUMsT0FBZSxFQUFFLEdBQUcsVUFBb0IsRUFBRSxFQUFFO1lBQzNELE9BQU8sSUFBSSxDQUFDLFVBQVcsQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLEdBQUcsVUFBVSxDQUFDLENBQUM7UUFDaEUsQ0FBQyxDQUFDO1FBRUYsa0JBQWEsR0FBRyxDQUFDLE9BQWUsRUFBRSxHQUFHLFVBQW9CLEVBQUUsRUFBRTtZQUMzRCxPQUFPLElBQUksQ0FBQyxVQUFXLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxHQUFHLFVBQVUsQ0FBQyxDQUFDO1FBQ2hFLENBQUMsQ0FBQztRQUVGOzs7Ozs7Ozs7OztXQVdHO1FBQ0gsV0FBTSxHQUFHLEdBQUcsRUFBRTtZQUNaLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUNyQyxDQUFDLENBQUM7UUFFRixrQkFBYSxHQUFHLEdBQUcsRUFBRTtZQUNuQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDakMsQ0FBQyxDQUFDO1FBRUY7Ozs7V0FJRztRQUNILFlBQU8sR0FBRyxHQUFHLEVBQUU7O1lBQ2IsTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRSxLQUFLLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztRQUN6QixDQUFDLENBQUM7UUE3S0EsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGVBQWUsQ0FBcUI7WUFDckQsSUFBSSxFQUFFLHNCQUFzQixDQUFDLFlBQVk7U0FDMUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGVBQWUsQ0FBNEIsSUFBSSxDQUFDLENBQUM7UUFFcEUsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFdEQsWUFBWTtRQUNaLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRTtZQUMxQyxJQUFJLENBQUMsU0FBUyxFQUFFO2dCQUNkLE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBRTFDLElBQUksV0FBbUIsQ0FBQztnQkFFeEIsUUFBUSxJQUFJLEVBQUU7b0JBQ1osS0FBSyxRQUFRLENBQUM7b0JBQ2QsS0FBSyxnQkFBZ0I7d0JBQ25CLFdBQVcsR0FBRywyQkFBMkIsQ0FBQzt3QkFDMUMsTUFBTTtvQkFDUixLQUFLLFNBQVM7d0JBQ1osV0FBVyxHQUFHLDRCQUE0QixDQUFDO3dCQUMzQyxNQUFNO29CQUNSLEtBQUssUUFBUTt3QkFDWCxXQUFXLEdBQUcsMkJBQTJCLENBQUM7d0JBQzFDLE1BQU07b0JBQ1I7d0JBQ0UsV0FBVyxHQUFHLDJCQUEyQixDQUFDO3dCQUMxQyxNQUFNO2lCQUNUO2dCQUVELElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO29CQUNoQixJQUFJLEVBQUUsc0JBQXNCLENBQUMsWUFBWTtvQkFDekMsaUJBQWlCLEVBQUUsS0FBSztvQkFDeEIsV0FBVztpQkFDWixDQUFDLENBQUM7Z0JBRUgsT0FBTzthQUNSO1lBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyx3QkFBd0IsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQzVELElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO29CQUNoQixJQUFJLEVBQUUsc0JBQXNCLENBQUMsWUFBWTtvQkFDekMsaUJBQWlCLEVBQUUsSUFBSTtvQkFDdkIsZ0JBQWdCLEVBQUUsS0FBSztpQkFDeEIsQ0FBQyxDQUFDO2dCQUVILE9BQU87YUFDUjtZQUVELFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBRXZELElBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDO1FBQzlCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQXdIRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFRlcnJhV2ViQ29ubmVjdG9yLFxuICBXZWJDb25uZWN0b3JTdGF0ZXMsXG4gIFdlYkNvbm5lY3RvclN0YXR1cyxcbiAgV2ViQ29ubmVjdG9yU3RhdHVzVHlwZSxcbiAgV2ViQ29ubmVjdG9yVHhSZXN1bHQsXG59IGZyb20gJ0B0ZXJyYS1kZXYvd2ViLWNvbm5lY3Rvci1pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ3JlYXRlVHhPcHRpb25zIH0gZnJvbSAnQHRlcnJhLW1vbmV5L3RlcnJhLmpzJztcbmltcG9ydCBib3dzZXIgZnJvbSAnYm93c2VyJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRDb25uZWN0b3IoaG9zdFdpbmRvdzoge1xuICB0ZXJyYVdlYkNvbm5lY3RvcnM6IFRlcnJhV2ViQ29ubmVjdG9yW10gfCB1bmRlZmluZWQ7XG59KTogUHJvbWlzZTxUZXJyYVdlYkNvbm5lY3RvciB8IHVuZGVmaW5lZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBsZXQgY291bnQgPSAyMDtcblxuICAgIGZ1bmN0aW9uIHRhc2soKSB7XG4gICAgICBpZiAoLS1jb3VudCA+IDApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBob3N0V2luZG93LnRlcnJhV2ViQ29ubmVjdG9ycyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGhvc3RXaW5kb3cudGVycmFXZWJDb25uZWN0b3JzKSAmJlxuICAgICAgICAgIGhvc3RXaW5kb3cudGVycmFXZWJDb25uZWN0b3JzLmxlbmd0aCA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgVGVycmFXZWJDb25uZWN0b3I6IGAsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShob3N0V2luZG93LnRlcnJhV2ViQ29ubmVjdG9yc1swXS5nZXRJbmZvKCkpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzb2x2ZShob3N0V2luZG93LnRlcnJhV2ViQ29ubmVjdG9yc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDYW4ndCBmaW5kIHdpbmRvdy50ZXJyYVdlYkNvbm5lY3RvcnMuIHdhaXQgNTAwbXMuLi5gKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KHRhc2ssIDUwMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0YXNrKCk7XG4gIH0pO1xufVxuXG5leHBvcnQgY2xhc3MgV2ViQ29ubmVjdG9yQ29udHJvbGxlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3N0YXR1czogQmVoYXZpb3JTdWJqZWN0PFdlYkNvbm5lY3RvclN0YXR1cz47XG4gIHByaXZhdGUgcmVhZG9ubHkgX3N0YXRlczogQmVoYXZpb3JTdWJqZWN0PFdlYkNvbm5lY3RvclN0YXRlcyB8IG51bGw+O1xuICBwcml2YXRlIF9jb25uZWN0b3I6IFRlcnJhV2ViQ29ubmVjdG9yIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBob3N0V2luZG93OiBXaW5kb3cpIHtcbiAgICB0aGlzLl9zdGF0dXMgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFdlYkNvbm5lY3RvclN0YXR1cz4oe1xuICAgICAgdHlwZTogV2ViQ29ubmVjdG9yU3RhdHVzVHlwZS5JTklUSUFMSVpJTkcsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9zdGF0ZXMgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFdlYkNvbm5lY3RvclN0YXRlcyB8IG51bGw+KG51bGwpO1xuXG4gICAgY29uc3QgYnJvd3NlciA9IGJvd3Nlci5nZXRQYXJzZXIobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgICAvL0B0cy1pZ25vcmVcbiAgICBnZXRDb25uZWN0b3IoaG9zdFdpbmRvdykudGhlbigoY29ubmVjdG9yKSA9PiB7XG4gICAgICBpZiAoIWNvbm5lY3Rvcikge1xuICAgICAgICBjb25zdCBuYW1lID0gYnJvd3Nlci5nZXRCcm93c2VyTmFtZSh0cnVlKTtcblxuICAgICAgICBsZXQgaW5zdGFsbExpbms6IHN0cmluZztcblxuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICBjYXNlICdjaHJvbWUnOlxuICAgICAgICAgIGNhc2UgJ21pY3Jvc29mdCBlZGdlJzpcbiAgICAgICAgICAgIGluc3RhbGxMaW5rID0gJ2h0dHBzOi8vZ29vZ2xlLmNvbS9jaHJvbWUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZmlyZWZveCc6XG4gICAgICAgICAgICBpbnN0YWxsTGluayA9ICdodHRwczovL2dvb2dsZS5jb20vZmlyZWZveCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzYWZhcmknOlxuICAgICAgICAgICAgaW5zdGFsbExpbmsgPSAnaHR0cHM6Ly9nb29nbGUuY29tL3NhZmFyaSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaW5zdGFsbExpbmsgPSAnaHR0cHM6Ly9nb29nbGUuY29tL2Nocm9tZSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXR1cy5uZXh0KHtcbiAgICAgICAgICB0eXBlOiBXZWJDb25uZWN0b3JTdGF0dXNUeXBlLk5PX0FWQUlMQUJMRSxcbiAgICAgICAgICBpc0Nvbm5lY3RvckV4aXN0czogZmFsc2UsXG4gICAgICAgICAgaW5zdGFsbExpbmssXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb25uZWN0b3IuY2hlY2tCcm93c2VyQXZhaWxhYmlsaXR5KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgIHRoaXMuX3N0YXR1cy5uZXh0KHtcbiAgICAgICAgICB0eXBlOiBXZWJDb25uZWN0b3JTdGF0dXNUeXBlLk5PX0FWQUlMQUJMRSxcbiAgICAgICAgICBpc0Nvbm5lY3RvckV4aXN0czogdHJ1ZSxcbiAgICAgICAgICBpc1N1cHBvcnRCcm93c2VyOiBmYWxzZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25uZWN0b3Iub3Blbihob3N0V2luZG93LCB0aGlzLl9zdGF0dXMsIHRoaXMuX3N0YXRlcyk7XG5cbiAgICAgIHRoaXMuX2Nvbm5lY3RvciA9IGNvbm5lY3RvcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZldGNoIHRoZSBjbGllbnRzU3RhdGVzXG4gICAqXG4gICAqIFlvdSBkb24ndCBuZWVkIGNhbGwgdGhpcyBtZXRob2QgaW4gbW9zdCBjYXNlcy5cbiAgICogTm9ybWFsbHksIHdoZW4gdGhlIGNsaWVudFN0YXRlcyBpcyBjaGFuZ2VkLCBzdGF0ZXMoKSBnZXQgdGhlIG5ldyBjbGllbnRTdGF0ZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNsaWVudC5zdGF0ZXMoKVxuICAgKiAgICAgICAuc3Vic2NyaWJlKHN0YXRlcyA9PiB7XG4gICAqICAgICAgICAgLy8gMi4gd2lsbCBnZXQgbmV3IGNsaWVudFN0YXRlc1xuICAgKiAgICAgICAgIGNvbnNvbGUubG9nKCdHb3QgbmV3IHN0YXRlcycsIERhdGUubm93KCkpXG4gICAqICAgICAgIH0pXG4gICAqXG4gICAqIGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgKiAgIC8vIDEuIHJlZmV0Y2ggY2xpZW50IHN0YXRlc1xuICAgKiAgIGNsaWVudC5yZWZldGNoU3RhdGVzKClcbiAgICogfVxuICAgKi9cbiAgcmVmZXRjaFN0YXRlcyA9ICgpID0+IHtcbiAgICB0aGlzLl9jb25uZWN0b3I/LnJlZmV0Y2hTdGF0ZXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVxdWVzdCBhcHByb3ZhbCBjb25uZWN0aW9uIHRvIHRoZSBFeHRlbnNpb24uIChDb25uZWN0KVxuICAgKi9cbiAgcmVxdWVzdEFwcHJvdmFsID0gKCkgPT4ge1xuICAgIHRoaXMuX2Nvbm5lY3Rvcj8ucmVxdWVzdEFwcHJvdmFsKCk7XG4gIH07XG5cbiAgc3RhdHVzID0gKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXMuYXNPYnNlcnZhYmxlKCk7XG4gIH07XG5cbiAgZ2V0TGFzdFN0YXR1cyA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzLmdldFZhbHVlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2xpZW50LnBvc3QodGVycmFBZGRyZXNzLCB0eDogQ3JlYXRlVHhPcHRpb25zKVxuICAgKiAgICAgICAuc3Vic2NyaWJlKHtcbiAgICogICAgICAgICAgbmV4dDogKHJlc3VsdDogV2ViQ29ubmVjdG9yVHhQcm9ncmVzcyB8IFdlYkNvbm5lY3RvclR4U3VjY2VlZCkgPT4ge1xuICAgKiAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0LnN0YXR1cykge1xuICAgKiAgICAgICAgICAgICAgY2FzZSBXZWJDb25uZWN0b3JUeFN0YXR1cy5QUk9HUkVTUzpcbiAgICogICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2luIHByb2dyZXNzJywgcmVzdWx0LnBheWxvYWQpXG4gICAqICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgKiAgICAgICAgICAgICAgY2FzZSBXZWJDb25uZWN0b3JUeFN0YXR1cy5TVUNDRUVEOlxuICAgKiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc3VjY2VlZCcsIHJlc3VsdC5wYXlsb2FkKVxuICAgKiAgICAgICAgICAgICAgICBicmVhaztcbiAgICogICAgICAgICAgICB9XG4gICAqICAgICAgICAgIH0sXG4gICAqICAgICAgICAgIGVycm9yOiAoZXJyb3IpID0+IHtcbiAgICogICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXZWJDb25uZWN0b3JVc2VyRGVuaWVkKSB7XG4gICAqICAgICAgICAgICAgICBjb25zb2xlLmxvZygndXNlciBkZW5pZWQnKVxuICAgKiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXZWJDb25uZWN0b3JDcmVhdGVUeEZhaWxlZCkge1xuICAgKiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2NyZWF0ZSB0eCBmYWlsZWQnLCBlcnJvci5tZXNzYWdlKVxuICAgKiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXZWJDb25uZWN0b3JUeEZhaWxlZCkge1xuICAgKiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3R4IGZhaWxlZCcsIGVycm9yLnR4aGFzaCwgZXJyb3IubWVzc2FnZSwgZXJyb3IucmF3X21lc3NhZ2UpXG4gICAqICAgICAgICAgICAgfSBlbHNlIHtcbiAgICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1bnNwZWNpZmllZCBlcnJvcicsICdtZXNzYWdlJyBpbiBlcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpKVxuICAgKiAgICAgICAgICAgIH1cbiAgICogICAgICAgICAgfVxuICAgKiAgICAgICB9KVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gVGhlIHN0cmVhbSB3aWxsIGJlXG4gICAqIFR4UHJvZ3Jlc3MgLT4gWy4uLlR4UHJvZ3Jlc3NdIC0+IFR4U3VjY2VlZFxuICAgKlxuICAgKiAtIFR4IGlzIFN1Y2NlZWQgOiBUeFByb2dyZXNzIC0+IFsuLi5UeFByb2dyZXNzXSAtPiBUeFN1Y2NlZWRcbiAgICovXG4gIHBvc3QgPSAoXG4gICAgdGVycmFBZGRyZXNzOiBzdHJpbmcsXG4gICAgdHg6IENyZWF0ZVR4T3B0aW9ucyxcbiAgKTogT2JzZXJ2YWJsZTxXZWJDb25uZWN0b3JUeFJlc3VsdD4gPT4ge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0b3IhLnBvc3QodGVycmFBZGRyZXNzLCB0eCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBDVzIwIFRva2VuIHRvIGV4dGVuc2lvbiBkYXNoYm9hcmRcbiAgICovXG4gIGFkZENXMjBUb2tlbnMgPSAoY2hhaW5JRDogc3RyaW5nLCAuLi50b2tlbkFkZHJzOiBzdHJpbmdbXSkgPT4ge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0b3IhLmFkZENXMjBUb2tlbnMoY2hhaW5JRCwgLi4udG9rZW5BZGRycyk7XG4gIH07XG5cbiAgaGFzQ1cyMFRva2VucyA9IChjaGFpbklEOiBzdHJpbmcsIC4uLnRva2VuQWRkcnM6IHN0cmluZ1tdKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RvciEuaGFzQ1cyMFRva2VucyhjaGFpbklELCAuLi50b2tlbkFkZHJzKTtcbiAgfTtcblxuICAvKipcbiAgICogQGV4YW1wbGVcbiAgICogY2xpZW50LnN0YXRlcygpXG4gICAqICAgICAgIC5zdWJzY3JpYmUoc3RhdGVzID0+IHtcbiAgICogICAgICAgICBpZiAoIXN0YXRlcykge1xuICAgKiAgICAgICAgICAgY29uc29sZS5sb2coJ2NsaWVudCBpcyBzdGlsbCBub3QgcmVhZHknKVxuICAgKiAgICAgICAgIH0gZWxzZSB7XG4gICAqICAgICAgICAgICBjb25zb2xlLmxvZygnY3VycmVudCBuZXR3b3JrIGlzJywgc3RhdGVzLm5ldHdvcmspXG4gICAqICAgICAgICAgICBjb25zb2xlLmxvZygnY3VycmVudCB3YWxsZXRzIGFyZScsIHN0YXRlcy53YWxsZXRzKVxuICAgKiAgICAgICAgIH1cbiAgICogICAgICAgfSlcbiAgICovXG4gIHN0YXRlcyA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGVzLmFzT2JzZXJ2YWJsZSgpO1xuICB9O1xuXG4gIGdldExhc3RTdGF0ZXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlcy5nZXRWYWx1ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoaXMgY2xpZW50XG4gICAqXG4gICAqIC0gVW5zdWJzY3JpYmUgYWxsIFJ4SnMgU3ViamVjdHMgKGV2ZXJ5IE9ic2VydmFibGVzIGFyZSBzdG9wZWQpXG4gICAqL1xuICBkZXN0cm95ID0gKCkgPT4ge1xuICAgIHRoaXMuX2Nvbm5lY3Rvcj8uY2xvc2UoKTtcbiAgICB0aGlzLl9jb25uZWN0b3IgPSBudWxsO1xuICB9O1xufVxuIl19